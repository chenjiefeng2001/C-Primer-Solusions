/**
 * @file 10.cpp
 * @author chenjiefeng2001(1497735430@qq.com)
 * @brief 泛型算法
 * @version 0.1
 * @date 2022-08-02
 *
 * @copyright Copyright (c) 2022
 *
 */
#include <iostream>
#include <cstring>
#include <vector>
#include <algorithm> //这是主要的算法
#include <numeric>   //这是数值算法的存放处
using namespace std;
//标准库容器定义的操作集合非常小，因为其并未给每个容器添加大量功能，而是提供了一组算法
//这些算法独立于特定的容器，因此被称为泛型的
//顺序容器只定义了很少的操作：在大多数情况下，我们可以添加或者删除元素、访问首尾元素、确定容器是否为空
//以及获得指向首元素或尾元素之后位置的迭代器
int main()
{
    //如果在vect中找到想要的元素，则返回结果指向它，否则返回结果为vec.cend()
    // int val=42;
    // auto result=find(vec.cbegin(),vec.cend(),val);
    int ia[] = {27, 210, 12, 47, 109, 83};
    int val = 83;
    int *result = find(begin(ia), end(ia), val);
    /**
     * @brief find执行的步骤
     * 1. 访问序列中的首元素
     * 2. 比较元素与我们要查找的值。
     * 3. 如果此元素与我们要查找的值相匹配，find返回标识此元素的值
     * 4. 否则，find前进到下一个元素，重复执行步骤2和3
     * 5. 如果达到序列尾，find响应停止
     * 6. 如果find达到序列末尾，它应该返回一个指出元素未找到的值。此值和步骤3返回的值必须具有相同的类型
     */
    //迭代器令算法不依赖于容器，但算法依赖于元素类型的操作
    /**
     * @brief 算法永远不会执行容器的操作
     * 泛型算法本身不会执行容器的操作，它们只会运行于迭代器之上，执行迭代器的操作。泛型算法运行于迭代器之上而不会执行容器操作的恶行带来了一个令人惊讶但非常必要的编程假定
     * 算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或者删除元素
     */


    return 0;
}
